<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Florin Cojocariu">
<meta name="dcterms.date" content="2024-04-04">

<title>Why ‘All Logic’ can’t be – Florin Cojocariu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script defer="" async="" src="https://tracker.hakanai.io/hakanai.min.js" data-site="c1fe82c6-73e8-4680-b675-9dd43b57cd35" data-link-tracking="true">
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../custom.css">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Florin Cojocariu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Why ‘All Logic’ can’t be</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
      </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#no-final-theory-of-all-logic" id="toc-no-final-theory-of-all-logic" class="nav-link active" data-scroll-target="#no-final-theory-of-all-logic">No Final Theory of All Logic?</a>
  <ul class="collapse">
  <li><a href="#aim-and-background" id="toc-aim-and-background" class="nav-link" data-scroll-target="#aim-and-background">1. Aim and Background</a></li>
  <li><a href="#limitative-theorems-and-self-description" id="toc-limitative-theorems-and-self-description" class="nav-link" data-scroll-target="#limitative-theorems-and-self-description">2. Limitative Theorems and Self-Description</a></li>
  <li><a href="#open-endedness-and-indefinite-extensibility" id="toc-open-endedness-and-indefinite-extensibility" class="nav-link" data-scroll-target="#open-endedness-and-indefinite-extensibility">3. Open-Endedness and Indefinite Extensibility</a></li>
  <li><a href="#a-schematic-no-final-theory-of-all-logic-claim" id="toc-a-schematic-no-final-theory-of-all-logic-claim" class="nav-link" data-scroll-target="#a-schematic-no-final-theory-of-all-logic-claim">4. A Schematic “No Final Theory of All Logic” Claim</a></li>
  <li><a href="#relation-to-logical-pluralism" id="toc-relation-to-logical-pluralism" class="nav-link" data-scroll-target="#relation-to-logical-pluralism">5. Relation to Logical Pluralism</a></li>
  <li><a href="#a-theological-analogy-explicitly-labeled-as-such" id="toc-a-theological-analogy-explicitly-labeled-as-such" class="nav-link" data-scroll-target="#a-theological-analogy-explicitly-labeled-as-such">6. A Theological Analogy (Explicitly Labeled as Such)</a></li>
  <li><a href="#status-of-the-argument" id="toc-status-of-the-argument" class="nav-link" data-scroll-target="#status-of-the-argument">7. Status of the Argument</a></li>
  <li><a href="#references-indicative-not-exhaustive" id="toc-references-indicative-not-exhaustive" class="nav-link" data-scroll-target="#references-indicative-not-exhaustive">References (indicative, not exhaustive)</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="All-Logic-Existence.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Why ‘All Logic’ can’t be</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Florin Cojocariu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 4, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>(maybe this should have started with the end, i.e.&nbsp;the PS)</p>
<div class="epigraph">
<p><em>“"My propositions serve as elucidations in the following way: anyone who understands me eventually recognizes them as nonsensical, when he has used them—as steps—to climb up beyond them. (He must, so to speak, throw away the ladder after he has climbed up it.) He must transcend these propositions, and then he will see the world aright."’</em></p>
<p>— Wittgenstein, <em>Tractatus</em> 6.54</p>
</div>
<section id="no-final-theory-of-all-logic" class="level1">
<h1>No Final Theory of All Logic?</h1>
<p><em>A Schematic Argument and Its Theological Analogy</em></p>
<section id="aim-and-background" class="level2">
<h2 class="anchored" data-anchor-id="aim-and-background">1. Aim and Background</h2>
<p>This note develops a simple line of thought:</p>
<ol type="1">
<li>Modern limitative theorems (Gödel, Tarski) show that no sufficiently strong formal theory can fully capture its own truth-theoretic profile (Gödel 1931; Tarski 1933/36).</li>
<li>Work on <em>indefinite extensibility</em> suggests that certain key concepts—set, truth, domain, and perhaps “validity”—are inherently open-ended (Dummett 1991; Williamson 1998).</li>
<li>Together, these support the claim that there is no <em>single, final</em> effectively axiomatized theory that exhaustively captures “all logic” while also providing a globally correct account of its own truth.</li>
<li>Read in a more speculative key, this yields an analogy with classical theistic claims about the in-principle uncapturability of a maximal, “God-like” reality by any finite scheme.</li>
</ol>
<p>None of this is new as a <em>theorem</em> of logic. The originality lies in the way standard results are packaged and connected.</p>
<hr>
</section>
<section id="limitative-theorems-and-self-description" class="level2">
<h2 class="anchored" data-anchor-id="limitative-theorems-and-self-description">2. Limitative Theorems and Self-Description</h2>
<p>Two classical results are central:</p>
<ul>
<li><p><strong>Gödel’s incompleteness theorems.</strong><br>
For any consistent, effectively axiomatized theory <span class="math inline">\(T\)</span> capable of representing elementary arithmetic, there are arithmetical truths expressible in the language of <span class="math inline">\(T\)</span> that are not provable in <span class="math inline">\(T\)</span> (Gödel 1931; see also Raatikainen 2020).</p></li>
<li><p><strong>Tarski’s undefinability theorem.</strong><br>
For any sufficiently strong formal system, truth in its intended model is not definable by a predicate of the system’s own language; there is no formula <span class="math inline">\(\mathsf{True}(x)\)</span> that picks out exactly the true sentences of that language (Tarski 1933/36).</p></li>
</ul>
<p>These theorems build on the technique of <em>arithmetization of syntax</em>: a theory such as first-order arithmetic can represent syntactic notions like “<span class="math inline">\(x\)</span> is a formula”, “<span class="math inline">\(x\)</span> is a proof of <span class="math inline">\(y\)</span>”, and so on, via Gödel coding.</p>
<p>We get a crucial contrast:</p>
<ul>
<li>Self-description of <strong>structure</strong> (syntax, provability, modelhood) can be internalized.</li>
<li>Self-description of <strong>truth</strong> (a full Tarskian truth predicate for one’s own language) cannot be internalized without inconsistency.</li>
</ul>
<p>Thus, any theory strong enough to talk sensibly about its own sentences and proofs is, in a precise sense, too weak to give a complete and correct theory of <em>its own</em> truth.</p>
<hr>
</section>
<section id="open-endedness-and-indefinite-extensibility" class="level2">
<h2 class="anchored" data-anchor-id="open-endedness-and-indefinite-extensibility">3. Open-Endedness and Indefinite Extensibility</h2>
<p>A parallel thread comes from the notion of <strong>indefinite extensibility</strong>, associated with Dummett and later developed by Williamson.</p>
<p>Very roughly, a concept <span class="math inline">\(C\)</span> is <em>indefinitely extensible</em> if:</p>
<blockquote class="blockquote">
<p>Whenever we have a definite grasp of some totality falling under <span class="math inline">\(C\)</span>, we can see how to extend it to a strictly larger totality still governed by the same concept.</p>
</blockquote>
<p>Classic candidates include:</p>
<ul>
<li><strong>Set</strong> or <strong>class</strong>: for any domain of sets, one can form new sets (e.g.&nbsp;of subsets, or of all sets in the domain) that fall outside the original totality.</li>
<li>Certain semantic notions, such as <strong>truth</strong>, where attempts to totalize all truths tend to push us to stronger languages or metalanguages (Dummett 1991; Williamson 1998).</li>
</ul>
<p>This framework gives us a vocabulary for talking about “no final encompassing standpoint”: the very nature of some concepts ensures that any given totalization can be properly extended.</p>
<p>When we ask about “all logic” in a very strong sense—<em>all</em> valid consequence relations, <em>all</em> formal systems, <em>all</em> semantic frameworks for them—we are plausibly dealing with something like an indefinitely extensible concept.</p>
<hr>
</section>
<section id="a-schematic-no-final-theory-of-all-logic-claim" class="level2">
<h2 class="anchored" data-anchor-id="a-schematic-no-final-theory-of-all-logic-claim">4. A Schematic “No Final Theory of All Logic” Claim</h2>
<p>Fix a standard background framework, such as ZFC, in which we can talk about formal languages, theories, proofs, and models.</p>
<p>Consider an open-ended family of logical “packages” <span class="math inline">\(\{P_n : n \in \mathbb{N}\}\)</span>, where each <span class="math inline">\(P_n\)</span> consists of:</p>
<ul>
<li>a language <span class="math inline">\(L_n\)</span>,</li>
<li>a designated class of models for <span class="math inline">\(L_n\)</span>,</li>
<li>a proof system,</li>
<li>and the usual metatheoretic apparatus we use to describe these.</li>
</ul>
<p>Write <span class="math inline">\(\mathscr{P} = \{P_n : n \in \mathbb{N}\}\)</span> for the class of all such packages we are prepared to define in the background theory.</p>
<p>In this setting, the following is <strong>not</strong> controversial:</p>
<ol type="1">
<li>Our background set theory can quantify over <span class="math inline">\(\mathscr{P}\)</span> as a (proper) class, exactly as it quantifies over “all groups,” “all models of ZFC,” etc.</li>
<li>For each <em>particular</em> logic <span class="math inline">\(P_n\)</span>, we can develop a metatheory describing its syntax, proof system, and models; often, much of this metatheory can be internalized in a sufficiently strong arithmetical or set-theoretic theory.</li>
</ol>
<p>The interesting question is different:</p>
<blockquote class="blockquote">
<p>Could there be a <em>single</em>, effectively axiomatized, consistent theory <span class="math inline">\(T^*\)</span> that<br>
(i) internalizes the usual syntax/semantics of <em>all</em> the <span class="math inline">\(P_n\)</span> in <span class="math inline">\(\mathscr{P}\)</span>;<br>
(ii) proves all the true arithmetical facts about their behaviour (e.g.&nbsp;consistency, completeness, theorems, etc.); <strong>and</strong><br>
(iii) contains a globally correct truth predicate not only for the languages <span class="math inline">\(L_n\)</span> but also for its <em>own</em> language?</p>
</blockquote>
<p>Conditions (i)–(ii) are very strong but, taken in isolation, not obviously inconsistent with standard practice: we routinely build rich “meta-theories of many logics.” The sticking point is (iii):</p>
<ul>
<li>By Tarski’s undefinability theorem, no sufficiently strong consistent theory can contain a predicate that exactly captures its own notion of truth.</li>
</ul>
<p>So any <span class="math inline">\(T^*\)</span> that aspires to be an all-encompassing, self-describing theory of “all logic” in this robust sense—pulling its own truth predicate into the same net—cannot succeed, on pain of contradiction.</p>
<p>Combined with Gödel’s incompleteness theorems, this yields a looser but philosophically potent slogan:</p>
<blockquote class="blockquote">
<p>For any fixed, effectively axiomatized, consistent, sufficiently strong theory <span class="math inline">\(T\)</span>, there are true statements about formal systems—including <span class="math inline">\(T\)</span> itself—that escape the reach of <span class="math inline">\(T\)</span>.</p>
</blockquote>
<p>Thus no such <span class="math inline">\(T\)</span>, treated as “just another formal theory,” can serve as a <em>final</em> theory of “all logic” in the ambitious, self-closing sense sketched above.</p>
<p>The conclusion is not that we cannot <em>talk</em> about all these logics (we can, in the background set theory), but that:</p>
<ul>
<li>any particular formalization we adopt as “the theory of all logic” will be, in principle, extendable and incomplete with respect to its own truth-theoretic profile and to stronger logical resources.</li>
</ul>
<p>In this sense, “all logic” functions as an <strong>ideal limit</strong>: approximated from within many systems, but never fully realized as a single, internally self-complete formal theory.</p>
<hr>
</section>
<section id="relation-to-logical-pluralism" class="level2">
<h2 class="anchored" data-anchor-id="relation-to-logical-pluralism">5. Relation to Logical Pluralism</h2>
<p>This view is compatible with, but distinct from, <strong>logical pluralism</strong>, the thesis that there is more than one correct logic (Russell 2013/2023).</p>
<ul>
<li>Pluralists argue on normative and semantic grounds that classical, intuitionistic, relevant, and so on, may all be “correct” in their own domains.</li>
<li>The present line of thought is not primarily about <em>normative correctness</em>, but about the <strong>non-finality of any single formal theory</strong> purporting to capture “all logical structure” and its own truth.</li>
</ul>
<p>The two themes can of course interact: if there is no single final theory of all logical consequence, that sits comfortably with the idea that the space of logics is open and plural. But the metalogical argument itself does not depend on pluralism.</p>
<hr>
</section>
<section id="a-theological-analogy-explicitly-labeled-as-such" class="level2">
<h2 class="anchored" data-anchor-id="a-theological-analogy-explicitly-labeled-as-such">6. A Theological Analogy (Explicitly Labeled as Such)</h2>
<p>If one is interested in philosophy of religion, there is a natural analogy here.</p>
<p>Many classical theistic traditions characterize God as:</p>
<ul>
<li>a maximal or ultimate reality,</li>
<li>the complete ground of order, being, or intelligibility,</li>
<li>in principle beyond full capture by any finite conceptual scheme.</li>
</ul>
<p>Ontological arguments typically proceed inside some relatively modest modal or higher-order framework: a particular logic <span class="math inline">\(L_n\)</span> plus axioms about necessity, essence, perfection, and so on. They aim to derive the existence of a maximal being from within that framework.</p>
<p>The metalogical picture above does <strong>not</strong> refute such arguments outright. But it does suggest a structural moral:</p>
<ul>
<li>Any formal argument is carried out in a specific system <span class="math inline">\(L_n\)</span>, with its own expressive limitations.</li>
<li>We have strong general reasons to think that no such system—when treated as just another formal theory—can be both (a) complete concerning its own truths and (b) self-sufficient as a final account of all logical structure.</li>
</ul>
<p>If the theist’s God is understood as “that than which no greater can be conceived,” or as the maximal ground of all being and intelligibility, then:</p>
<ul>
<li>the <strong>open-endedness</strong> of our best formal frameworks, and</li>
<li>the impossibility of any one of them fully capturing its own truth and all stronger frameworks,</li>
</ul>
<p>can be read as a formal echo of the intuition that no single finite scheme—logical or otherwise—can <em>finally</em> domesticate such a reality.</p>
<p>This is, emphatically, an <em>analogy</em>, not a proof:</p>
<ul>
<li>Logic does not entail that such a maximal reality exists.</li>
<li>Nor does it prove that no formal argument about God can ever be sound.</li>
</ul>
<p>But it does provide a disciplined way of saying:</p>
<blockquote class="blockquote">
<p>Even in our most precise and austere theories, the aspiration to a single, self-contained, final theory of “all logic” is blocked by principled limitations. If there is a maximal reality, we should not be surprised if it resists capture by any one such theory as well.</p>
</blockquote>
<hr>
</section>
<section id="status-of-the-argument" class="level2">
<h2 class="anchored" data-anchor-id="status-of-the-argument">7. Status of the Argument</h2>
<p>As far as I know, no existing result in mathematical logic is commonly stated as <em>“the non-existence of a final theory of all logic”</em> in the precise format above. What exists are:</p>
<ul>
<li>Gödel’s and Tarski’s limit theorems, and their many refinements;</li>
<li>philosophical work on indefinite extensibility and the open-endedness of key concepts;</li>
<li>discussions of logical pluralism and the diversity of consequence relations.</li>
</ul>
<p>The present line of argument is best understood as a <strong>synthesis</strong> of these strands, pushed in a specific, higher-level direction (plus a theological gloss).</p>
<hr>
</section>
<section id="references-indicative-not-exhaustive" class="level2">
<h2 class="anchored" data-anchor-id="references-indicative-not-exhaustive">References (indicative, not exhaustive)</h2>
<ul>
<li>Dummett, M. (1991). <em>The Logical Basis of Metaphysics</em>. Harvard University Press.<br>
</li>
<li>Gödel, K. (1931). “Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I.” <em>Monatshefte für Mathematik und Physik</em>, 38, 173–198.<br>
</li>
<li>Russell, G. (2013/2023). “Logical Pluralism.” In <em>The Stanford Encyclopedia of Philosophy</em>, ed.&nbsp;E. N. Zalta &amp; U. Nodelman.<br>
</li>
<li>Tarski, A. (1933/1956). “The Concept of Truth in Formalized Languages.” In <em>Logic, Semantics, Metamathematics</em>, 2nd ed., Hackett, 1983.<br>
</li>
<li>Williamson, T. (1998). “Indefinite Extensibility.” <em>Mind</em>, 107(427), 453–473.</li>
</ul>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The very act of trying to say “All logic exists” (if by a "logic" we understand the totality of its semantic and syntactic components, regardless of its proof-theoretic and model-theoretic entailment) in any particular logical system undermines itself. We’re left with:</p>
<ul>
<li><p>Particular logics we can work with (<span class="math inline">\(L_1\)</span>, <span class="math inline">\(L_2\)</span>, etc.)</p></li>
<li><p>Grand claims about “all logic” that forever escape formalization</p></li>
</ul>
<p>PS: This was a short text written on the margin of the Ontological Argument. It reveals why the entire tradition of ontological arguments—from Anselm’s Proslogion to contemporary modal versions—commits a fundamental category error. If God represents ultimate reality or the source of all possible being, then God functions like our set P: the totality that encompasses all formal systems. But then any attempt to prove God’s existence within a particular logical framework Lₖ faces the structural impossibility we have demonstrated—the system cannot formalize claims about what transcends its own boundaries. For philosophers, this provides a precise, formal reason why centuries of increasingly sophisticated ontological arguments have failed to compel: the enterprise itself is structurally incoherent. For believers, this offers unexpected liberation—faith need not await logical vindication because the divine necessarily exceeds the grasp of human formal systems. Rather than viewing this as a defeat for theism, it preserves what many traditions have long insisted: that God belongs to the realm of encounter and commitment, not demonstration and proof. The mystery remains mysterious not due to our current limitations, but due to the very structure of formal discourse itself.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "aathanor/Philosophy";
    script.dataset.repoId = "R_kgDOOvbpNQ";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDOOvbpNc4CqifF";
    script.dataset.mapping = "pathname";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "bottom";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->




</body></html>